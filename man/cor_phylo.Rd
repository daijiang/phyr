% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/cor_phylo.R
\name{cor_phylo}
\alias{cor_phylo}
\alias{print.cor_phylo}
\title{Correlations among multiple traits with phylogenetic signal}
\usage{
cor_phylo(formulas, species, phy, data = sys.frame(sys.parent()),
  REML = TRUE, method = c("neldermead", "bobyqa", "sbplx", "cobyla",
  "praxis", "neldermead-r"), constrain_d = FALSE, rel_tol = 1e-06,
  max_iter = 1000, verbose = FALSE, boot = 0, n_cores = 1)

\method{print}{cor_phylo}(x, digits = max(3, getOption("digits") - 3), ...)
}
\arguments{
\item{formulas}{a list of \code{p} formulas (class \code{\link{formula}}),
one formula for each trait of interest. Formulas should take one of the following
forms:
\describe{
\item{\code{trait ~ 1}}{traits without covariates or measurement error}
\item{\code{trait ~ covariate_1 + ... + covariate_N}}{
traits with \code{N} covariates
}
\item{\code{trait ~ 1 | measurement error}}{
traits with measurement error indicated by standard errors in
the \code{measurement error} column/vector
}
\item{\code{trait ~ covariate_1 + ... + covariate_N | measurement error}}{
traits with both covariates and measurement error
}
}}

\item{species}{the column name or object in \code{data} that indicates the species.
You do not need to use quotes for this argument,
but quotes will not adversely affect the outcome.}

\item{phy}{a \code{phylo} object giving the phylogenetic tree.}

\item{data}{an optional data frame, list, or environment that contains the
variables in the model. By default, variables are taken from the environment
from which \code{cor_phylo} was called.}

\item{REML}{whether REML (versus ML) should be used for model fitting.
Defaults to \code{TRUE}.}

\item{method}{method of optimization using \code{nlopt}. Options include
"neldermead", "bobyqa", "sbplx", "cobyla", "praxis". See
\url{https://nlopt.readthedocs.io/en/latest/NLopt_Algorithms/} for more
information.}

\item{constrain_d}{if \code{constrain_d} is \code{TRUE}, the estimates of \code{d} are
constrained to be between zero and 1. This can make estimation more stable and
can be tried if convergence is problematic. This does not necessarily lead to
loss of generality of the results, because before using \code{cor_phylo},
branch lengths of \code{phy} can be transformed so that the "starter" tree
has strong phylogenetic signal.
Defaults to \code{FALSE}.}

\item{rel_tol}{a control parameter dictating the relative tolerance for convergence
in the optimization; see \code{optim()}.
Defaults to \code{1e-6}.}

\item{max_iter}{a control parameter dictating the maximum number of iterations
in the optimization. Defaults to \code{1000}.}

\item{verbose}{if \code{TRUE}, the model \code{logLik} and running estimates of the
correlation coefficients and values of \code{d} are printed each iteration
during optimization. Defaults to \code{FALSE}.}

\item{boot}{Number of parametric bootstrap replicates. Defaults to \code{0}.}

\item{n_cores}{Number of cores to use for parametric bootstrapping.
This argument is ignored if OpenMP is not enabled. Defaults to \code{1}.}

\item{x}{an object of class \code{cor_phylo}.}

\item{digits}{the number of digits to be printed.}

\item{...}{arguments passed to and from other methods.}
}
\value{
An object of class \code{cor_phylo}:
\item{\code{corrs}}{the \code{p} x \code{p} matrix of correlation coefficients.}
\item{\code{d}}{values of \code{d} from the OU process for each trait.}
\item{\code{B}}{a matrix of regression-coefficient estimates, SE, Z-scores, and P-values,
respectively. Rownames indicate which coefficient it refers to.}
\item{\code{B_cov}}{covariance matrix for regression coefficients.}
\item{\code{logLik}}{the log likelihood for either the restricted likelihood
(\code{REML = TRUE}) or the overall likelihood (\code{REML = FALSE}).}
\item{\code{AIC}}{AIC for either the restricted likelihood (\code{REML = TRUE}) or the
overall likelihood (\code{REML = FALSE}).}
\item{\code{BIC}}{BIC for either the restricted likelihood (\code{REML = TRUE}) or the
overall likelihood (\code{REML = FALSE}).}
\item{\code{niter}}{Number of iterations the optimizer used.}
\item{\code{convcode}}{Conversion code for the optimizer, which is positive on success
and negative on failure. See also
\url{https://nlopt.readthedocs.io/en/latest/NLopt_Reference/#return-values}.}
\item{\code{call}}{the matched call.}
}
\description{
This function calculates Pearson correlation coefficients for multiple continuous
traits that may have phylogenetic signal, allowing users to specify measurement
error as the standard error of trait values at the tips of the phylogenetic tree.
Phylogenetic signal for each trait is estimated from the data assuming that trait
evolution is given by a Ornstein-Uhlenbeck process.  Thus, the function allows the
estimation of phylogenetic signal in multiple traits while incorporating
correlations among traits. It is also possible to include independent variables
(covariates) for each trait to remove possible confounding effects.
\code{cor_phylo} returns the correlation matrix for trait values, estimates
of phylogenetic signal for each trait, and regression coefficients for
independent variables affecting each trait.

\code{print.cor_phylo} prints \code{cor_phylo} objects
}
\details{
For the case of two variables, the function estimates parameters for the model of
the form, for example,

\deqn{X[1] =  B[1,0] + B[1,1] * u[1,1] + \epsilon[1]}
\deqn{X[2] =  B[2,0] + B[2,1] * u[2,1] + \epsilon[2]}
\deqn{\epsilon ~ Gaussian(0, V) }

where \eqn{B[1,0]}, \eqn{B[1,1]}, \eqn{B[2,0]}, and \eqn{B[2,1]} are regression
coefficients, and \eqn{V} is a variance-covariance matrix containing the correlation
coefficient r, parameters of the OU process \eqn{d1} and \eqn{d2}, and diagonal
matrices \eqn{M1} and \eqn{M2} of measurement standard errors for \eqn{X[1]} and
\eqn{X[2]}. The matrix \eqn{V} is \eqn{2n x 2n}, with \eqn{n x n} blocks given by

\deqn{V[1,1] = C[1,1](d1) + M1}
\deqn{V[1,2] = C[1,2](d1,d2)}
\deqn{V[2,1] = C[2,1](d1,d2)}
\deqn{V[2,2] = C[2,2](d2) + M2}

where \eqn{C[i,j](d1,d2)} are derived from \code{phy} under the assumption of joint
OU evolutionary processes for each trait (see Zheng et al. 2009). This formulation
extends in the obvious way to more than two traits.
}
\examples{

## Simple example using data without correlations or phylogenetic
## signal. This illustrates the structure of the input data.

phy <- ape::rcoal(10, tip.label = 1:10)
data_df <- data.frame(species = phy$tip.label,
                      par1 = rnorm(10),
                      par2 = rnorm(10),
                      cov2 = rnorm(10, mean = 10, sd = 4),
                      se1 = 0.2,
                      se2 = 0.4)
data_df$par2 <- data_df$par2 + 0.5 * data_df$cov2

cor_phylo(list(par1 ~ 1 | se1, par2 ~ cov2 | se2),
          species = species, phy = phy, data = data_df,
          method = "neldermead")


\dontrun{
    ## Simulation example for the correlation between two variables. The example
    ## compares the estimates of the correlation coefficients from cor_phylo when
    ## measurement error is incorporated into the analyses with three other cases:
    ## (i) when measurement error is excluded, (ii) when phylogenetic signal is
    ## ignored (assuming a "star" phylogeny), and (iii) neither measurement error
    ## nor phylogenetic signal are included.
    
    # In the simulations, variable 2 is associated with a single independent variable.
    
    library(ape)
    
    set.seed(1)
    # Set up parameter values for simulating data
    n <- 50
    phy <- rcoal(n, tip.label = 1:n)
    
    R <- matrix(c(1, 0.7, 0.7, 1), nrow = 2, ncol = 2)
    d <- c(0.3, 0.95)
    B2 <- 1
    
    Se <- c(0.2, 1)
    M <- matrix(Se, nrow = n, ncol = 2, byrow = TRUE)
    
    # Set up needed matrices for the simulations
    p <- length(d)
    
    star <- stree(n)
    star$edge.length <- array(1, dim = c(n, 1))
    star$tip.label <- phy$tip.label
    
    Vphy <- vcv(phy)
    Vphy <- Vphy/max(Vphy)
    Vphy <- Vphy/exp(determinant(Vphy)$modulus[1]/n)
    
    tau <- matrix(1, nrow = n, ncol = 1) \%*\% diag(Vphy) - Vphy
    C <- matrix(0, nrow = p * n, ncol = p * n)
    for (i in 1:p) for (j in 1:p) {
        Cd <- (d[i]^tau * (d[j]^t(tau)) * (1 - (d[i] * d[j])^Vphy))/(1 - d[i] * d[j])
        C[(n * (i - 1) + 1):(i * n), (n * (j - 1) + 1):(j * n)] <- R[i, j] * Cd
    }
    MM <- matrix(M^2, ncol = 1)
    V <- C + diag(as.numeric(MM))
    
    # Perform a Cholesky decomposition of Vphy. This is used to generate phylogenetic
    # signal: a vector of independent normal random variables, when multiplied by the
    # transpose of the Cholesky deposition of Vphy will have covariance matrix
    # equal to Vphy.
    iD <- t(chol(V))
    
    # Create mostly empty data frame for input to cor_phylo
    data_df <- data.frame(species = phy$tip.label,
                          par1 = numeric(n),
                          par2 = numeric(n),
                          cov2 = numeric(n),
                          se1 = Se[1],
                          se2 = Se[2])
    
    # Perform Nrep simulations and collect the results
    Nrep <- 100
    cor.list <- matrix(0, nrow = Nrep, ncol = 1)
    cor.noM.list <- matrix(0, nrow = Nrep, ncol = 1)
    cor.noP.list <- matrix(0, nrow = Nrep, ncol = 1)
    cor.noMP.list <- matrix(0, nrow = Nrep, ncol = 1)
    d.list <- matrix(0, nrow = Nrep, ncol = 2)
    d.noM.list <- matrix(0, nrow = Nrep, ncol = 2)
    B.list <- matrix(0, nrow = Nrep, ncol = 3)
    B.noM.list <- matrix(0, nrow = Nrep, ncol = 3)
    B.noP.list <- matrix(0, nrow = Nrep, ncol = 3)
    
    set.seed(2)
    for (rep in 1:Nrep) {
        
        XX <- iD \%*\% rnorm(2 * n)
        
        data_df$cov2 <- rnorm(n, mean = 2, sd = 10)
        data_df$par1 <- XX[1:n]
        data_df$par2 <- XX[(n+1):(2*n)] + B2[1] * data_df$cov2 - B2[1] * 
                        mean(data_df$cov2)
        
        # Call cor_phylo with (i) phylogeny and measurement error,
        # (ii) just phylogeny,
        # and (iii) just measurement error
        z <- cor_phylo(list(par1 ~ 1 | se1, par2 ~ cov2 | se2),
                       phy = phy,
                       species = species, data = data_df,
                       method = "neldermead")
        z.noM <- cor_phylo(list(par1 ~ 1, par2 ~ cov2),
                           phy = phy,
                           species = species, data = data_df,
                           method = "neldermead")
        z.noP <- cor_phylo(list(par1 ~ 1 | se1, par2 ~ cov2 | se2),
                           phy = star,
                           species = species, data = data_df,
                           method = "neldermead")
    
        cor.list[rep] <- z$corrs[1, 2]
        cor.noM.list[rep] <- z.noM$corrs[1, 2]
        cor.noP.list[rep] <- z.noP$corrs[1, 2]
        cor.noMP.list[rep] <- cor(cbind(
            lm(data_df$par1 ~ 1)$residuals,
            lm(data_df$par2 ~ data_df$cov2)$residuals))[1,2]
        
        d.list[rep, ] <- z$d
        d.noM.list[rep, ] <- z.noM$d
        
        B.list[rep, ] <- z$B[,1]
        B.noM.list[rep, ] <- z.noM$B[,1]
        B.noP.list[rep, ] <- z.noP$B[,1]
        
        show(c(rep, z$convcode, z$cor.matrix[1, 2], z$d))
    }
    
    correlation <- rbind(R[1, 2], mean(cor.list), mean(cor.noM.list),
                         mean(cor.noP.list), mean(cor.noMP.list))
    rownames(correlation) <- c("True", "With M and Phy", "Without M",
                               "Without Phy", "Without Phy or M")
    
    signal.d <- rbind(d, colMeans(d.list), colMeans(d.noM.list))
    rownames(signal.d) <- c("True", "With M and Phy", "Without M")
    
    est.B <- rbind(c(0, 0, B2), colMeans(B.list), 
                   colMeans(B.noM.list[-39,]),  # 39th rep didn't converge
                   colMeans(B.noP.list))
    rownames(est.B) <- c("True", "With M and Phy", "Without M", "Without Phy")
    colnames(est.B) <- rownames(z$B)
    
    # Example simulation output:

    correlation
    #                       [,1]
    # True             0.7000000
    # With M and Phy   0.6982181
    # Without M        0.2981836
    # Without Phy      0.3716215
    # Without Phy or M 0.3291473

    signal.d
    #                     [,1]      [,2]
    # True           0.3000000 0.9500000
    # With M and Phy 0.3061635 0.9418578
    # Without M      0.2405632 0.4013655

    est.B
    #                      par1_0    par2_0 par2_cov2
    # True            0.000000000 0.0000000 1.0000000
    # With M and Phy -0.008680443 0.1093704 0.9996207
    # Without M      -0.008561169 0.1146912 0.9982136
    # Without Phy     0.002933341 0.1096578 1.0028468
    
}


}
\references{
Zheng, L., A. R. Ives, T. Garland, B. R. Larget, Y. Yu, and K. F. Cao.
2009. New multivariate tests for phylogenetic signal and trait correlations
applied to ecophysiological phenotypes of nine \emph{Manglietia} species.
\emph{Functional Ecology} \bold{23}:1059--1069.
}
\author{
Anthony R. Ives, Lucas A. Nell
}
\keyword{regression}

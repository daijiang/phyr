---
title: "ancestral_benchmark"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{ancestral_benchmark}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```
This vignette tests how much speed up in `pglmm` models we can get using the `ancestral` mode. It also shows how to extract ancestral character estimates for site occupancy using this mode, and how to use it to model data when you have values for ancestral nodes as well as tips.

First we create a function to simulate data with nested phylogenetic effects, that is, where occupancy across a set of sites has phylogenetic structure (specifically phylogenetic clustering in this case).

```{r setup}
library(phyr)
library(ape)
library(rbenchmark)
library(ggplot2)

set.seed(20012021)

sim_phylo_comm <- function(nspp, nsite = 10, phy_nested_sd = 1, 
                           phy_unnested_sd = 1, site_sd = 1,
                           beta0 = 1, resid_sd = 1) {
  
  # construct phylogeny from 'ape'
  phy <- rcoal(nspp)
  phy <- compute.brlen(phy, method = "Grafen", power = 0.5)
  # set up phylogenetic attraction covariance matrix which requires a nested covariance   matrix for phylogenetic attraction
  Vphy <- vcv(phy)
  Vphy <- Vphy / max(Vphy)
  Vphy <- Vphy / exp(determinant(Vphy)$modulus[1] / nspp)
  
  # Perform a Cholesky decomposition of Vphy. This is used to generate phylogenetic
  # signal: a vector of independent normal random variables, when multiplied by the
  # transpose of the Cholesky deposition of Vphy will have covariance matrix
  # equal to Vphy. Another way is to use mvtnorm package.
  cholVnested = Matrix::t(Matrix::chol(kronecker(Matrix::Matrix(diag(1, nrow = nsite)), Matrix::Matrix(Vphy, sparse = TRUE)))) # nested component
  
  ## just phylogenetic effect
  b0_sp <- rTraitCont(phy, sigma = phy_unnested_sd * Vphy[1,1]^.5) 
  ## just site effect
  b0_site <- rnorm(nsite, sd = site_sd)
  
  # set up data.frame for parameters
  B <- data.frame(
    spec = rep(rownames(Vphy), times = nsite),
    site = rep(seq_len(nsite), each = nspp),
    b0_sp = rep(b0_sp, times = nsite),
    b0_site = rep(b0_site, each = nspp)
  )
  
  y <- beta0 + B$b0_sp + B$b0_site +
    as.matrix(cholVnested %*% Matrix::Matrix(rnorm(nsite * nspp, sd = phy_nested_sd),
                                   sparse = TRUE)) +
    rnorm(nspp * nsite, sd = resid_sd)
  
  list(phy = phy, data = cbind(y = y, B[ , c("spec", "site")]))
  
}

test <- sim_phylo_comm(20)
test$data
plot(test$phy)
```
Okay, now we setup a series of simulation and fit models to each. We will try several different diversities as twe likely will only see speedups when there are many species. We will also compare the estimates using `ancestral` mode to the regular `phyr` mode to make sure they are consistent.

```{r sim_and_fit} 

n_tips <- c(10, 25, 50, 75, 100, 150, 200, 250, 300)
sims <- lapply(n_tips,
               sim_phylo_comm)

fit_and_bench <- function(sim) {
  
  bench <- rbenchmark::benchmark(
    mod = {
      mod <- pglmm(formula = y ~ 1 + (1 | spec__) +
                     (1 | site) + (1 | spec__@site), 
                   repulsion = F, family = "gaussian", 
                   cov_ranef = list(spec = sim$phy), 
                   data = sim$data, verbose = F, 
                   bayes = T,
                   prior = "pc.prior.auto")
    },
    
    mod_anc = {
      mod_anc <- pglmm(formula = y ~ 1 + (1 | spec__) +
                     (1 | site) + (1 | spec__@site), 
                   repulsion = F, family = "gaussian", 
                   cov_ranef = list(spec = sim$phy), 
                   data = sim$data, verbose = F, 
                   bayes = T,
                   prior = "pc.prior.auto",
                   ancestral = "spec")
    },
    replications = 1,
    columns = c("test", "replications", "elapsed",
                "relative", "user.self", "sys.self")
  )
  print(length(sim$phy$tip.label))
  list(bench = bench, mod = mod, mod_anc = mod_anc)
}

results <- lapply(sims,
                  fit_and_bench)
```
Let's plot that:

```{r plot_it}

res_df <- lapply(seq_along(results), function(x) data.frame(method = c("Standard",
                                                                       "Ancestral"),
                                                 elapsed = results[[x]]$bench$elapsed,
                                                 num_tips = n_tips[x]))

res_df <- do.call(rbind, res_df)

ggplot(res_df, aes(num_tips, elapsed)) +
  geom_point(aes(colour = method), size = 2) +
  geom_path(aes(colour = method)) +
  theme_minimal()

```

That is much faster! Now let's see if the two methods produce similar results. We will just look at random effects estimates here.

```{r compare_each}
re_df_1 <- lapply(seq_along(results), function(x) data.frame(method = "Standard",
                                      re = c(results[[x]]$mod$s2r,
                                             results[[x]]$mod$s2n,
                                             results[[x]]$mod$s2resid),
                                      lower = c(results[[x]]$mod$s2r.ci[ , 1],
                                                results[[x]]$mod$s2n.ci[ , 1],
                                                results[[x]]$mod$s2resid.ci[ , 1]),
                                      upper = c(results[[x]]$mod$s2r.ci[ , 2],
                                                results[[x]]$mod$s2n.ci[ , 2],
                                                results[[x]]$mod$s2resid.ci[ , 2]),
                                      num_tips = n_tips[x],
                                      effect = c(names(results[[x]]$mod$s2r),
                                                 names(results[[x]]$mod$s2n),
                                                 names(results[[x]]$mod$s2resid))))

re_df_1 <- do.call(rbind, re_df_1)

re_df_2 <- lapply(seq_along(results), function(x) data.frame(method = "Ancestral",
                                      re = c(results[[x]]$mod_anc$s2r,
                                             results[[x]]$mod_anc$s2n,
                                             results[[x]]$mod_anc$s2resid),
                                      lower = c(results[[x]]$mod_anc$s2r.ci[ , 1],
                                                results[[x]]$mod_anc$s2n.ci[ , 1],
                                                results[[x]]$mod_anc$s2resid.ci[ , 1]),
                                      upper = c(results[[x]]$mod_anc$s2r.ci[ , 2],
                                                results[[x]]$mod_anc$s2n.ci[ , 2],
                                                results[[x]]$mod_anc$s2resid.ci[ , 2]),
                                      num_tips = n_tips[x],
                                      effect = c(names(results[[x]]$mod_anc$s2r),
                                                 names(results[[x]]$mod_anc$s2n),
                                                 names(results[[x]]$mod_anc$s2resid))))

re_df_2 <- do.call(rbind, re_df_2)

re_df <- rbind(re_df_1, re_df_2)

ggplot(re_df, aes(effect, re)) +
  geom_point(aes(colour = method), position = position_dodge(width = 0.5)) +
  geom_errorbar(aes(ymin = lower, ymax = upper, colour = method),
                position = position_dodge(width = 0.5)) +
  facet_wrap(~ num_tips, ncol = 3, scales = "free_y") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = -90))
```

Okay, they produce very nearly identical results, so it looks like everything is good!

